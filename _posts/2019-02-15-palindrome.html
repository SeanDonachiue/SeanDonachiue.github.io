---
layout: post
author: Sean
title: Max Length Palindromic Substring
---
<p>I recently had the pleasure of undergoing my first technical coding interview. Unfortunately, I took the wrong approach to solving the following problem: Given a string of arbitrary length, find the longest palindrome it contains. The solution I set off with, somewhat embarrasingly, was to use a pointer i, set to the front of the string, and a pointer j, set to the back of the string, checking for character equality on each iteration of a loop, decrementing j for each comparison, but only incrementing i if the comparison was true... Then if a non equal character pairing is found, revert i to a prior value and keep checking j. Finally, if j == i, break, because you MUST have checked the whole string. Also, somewhere along the way, we wanted to be storing the indices of the start and end of the current max length palindrome. But it doesn't matter where we were going to do that, because the whole thing is wrong!</p>
<p>The above approach leaves palindromes in the left half of the list unexamined. Additionally, its not clear that it even finds palindromes in the right half. So... what happened? Why did I start implementing this solution? During the interview, I thought, let's break the problem to something simpler. Instead of finding the longest palindrome, how can we just determine if a substring is a palindrome. This gives a fairly close solution to what I had, where you iterate pointers on either end towards each other as long as the characters they are pointing at are equal, but as soon as the longest palindrome is not symmetrical across the middle of the string, it doesn't return the optimal solution.</p>
<p>The correct approach: We needed to make the problem even smaller than that. What is the smallest length palindrome? One containing only a single letter. All single letter substrings are palindromes, and this single letter palindrome is always the middle index of a longer palindrome. So, we can start with the first letter in the string, and then check letters on either side of it for equality. If while doing this, one of our pointers goes past either end of the list, or the values pointed at are no longer equal, we iterate our pointer identifying the "middle" of the palindrome currently being checked. At each step, we store the max length palindrome and the index of its middle character. When the algorithm terminates, we can determine the substring to return from these values with input.substring(middleIndex - length/2, middleIndex + length/2)</p>
<p>Because this approach treats each letter in the string as the center of a potential palindrome, it always returns the optimal solution. I wouldnt be surprised if there exists a dynamic programming solution that is faster, but it is beyond my ability to think up at this time.</p>

<form onsubmit="isPalindrome(document.getElementById(palindromeIn).value);">
    String to Check:<br>
    <input id="palindromeIn" type="text" value=""><br>
    <input type="submit">
</form>

<p id="max-length-palindrome">output</p>

<script type="text/javascript">
    function isPalindrome(String input) {
        console.log("start of palindrome test");
        int maxLength = 1;
        int maxMidIndex = 1;
        
        for(int k = 1; k < input.length; k++) {
            console.log("outer loop");
            int j = k + 1;
            int currMax = 1;
            for(int i = k - 1; i >= 0; i--) {
                //if the characters are equal, iterate the currmax values and continue
                //if the currmax is then greater than the maxlength thus far. 
               console.log("inner loop");
                
                //other reasons to break are... j goes over the edge, i goes over the edge
                if(j >= input.length) break;
                if(input[i] !== input[j]) break;
                else if(input[i] === input[j]) {
                    currMax += 2;
                    if(currMax > maxLength) {
                        maxLength = currMax;
                        maxMidIndex = k;
                    } 
                }
                
                j++;
            }
        }
        //set the output to the max length palindrome.
        document.getElementById(max-length-palindrome).innerHTML = input.substring(maxMidIndex - maxLength/2, maxMidIndex + maxLength/2);
    }
</script>

<p>April 8, 2019 Update: While relating the above experience and solutions to a former classmate a few weeks ago, I realized the problem can be solved by pushing the string to a stack, then </p>