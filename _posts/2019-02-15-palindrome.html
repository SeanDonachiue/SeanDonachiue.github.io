---
layout: post
author: Sean
title: Max Length Palindrome Substring
---
<p>I recently had the pleasure of my first technical interview coding questions. Unfortunately, I took the wrong approach to solving the following problem: Given a string of arbitrary length, find the longest palindrome it contains. The solution I set off with, somewhat embarrasingly, was to use a pointer i, set to the front of the string, and a pointer j, set to the back of the string, checking for character equality on each iteration of a loop, decrementing j for each comparison, but only incrementing i if the comparison was true... Then if a non equal character pairing is found, revert i to a prior value and keep checking j. Finally, if j == i, break, because you MUST have checked the whole string. Also, somewhere along the way, we wanted to be storing the indices of the start and end of the current max length palindrome. But it doesn't matter where we were going to do that, because the whole thing is wrong!</p>
<p>The above approach leaves palindromes in the left half of the list unexamined. Additionally, its not clear that it even finds palindromes in the right half. So... what happened? Why did I start implementing this solution? During the interview, I thought, let's break the problem to something simpler. Instead of finding the longest palindrome, how can we just determine if a substring is a palindrome. This gives a fairly close solution to what I had, where you iterate pointers on either end towards each other as long as the characters they are pointing at are equal, but as soon as the longest palindrome is not symmetrical across the middle of the string, it doesn't return the optimal solution.</p>
<p>The correct approach: We needed to make the problem even smaller than that. What is the smallest length palindrome? One containing only a single letter. All single letter substrings are palindromes, and this single letter palindrome is always the middle index of a longer palindrome. So, we can start with the first letter in the string, and then check letters on either side of it for equality. If while doing this, one of our pointers goes past either end of the list, or the values pointed at are no longer equal, we iterate our pointer identifying the "middle" of the palindrome currently being checked. At each step, we store the max length palindrome and the index of its middle character. When the algorithm terminates, we can determine the substring to return from these values with input.substring(middleIndex - length/2, middleIndex + length/2)</p>
<p>Because this approach treats each letter in the string as the center of a potential palindrome, it always returns the optimal solution. Its basically brute force search just made complicated by the triple pointer action. Surely there exists a dynamic programming solution that is a bit faster, but it is beyond my ability to think up at this time.</p>
<script>